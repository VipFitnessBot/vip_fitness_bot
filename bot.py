import asyncio
import hashlib
import hmac
import json
import logging
import time
from datetime import datetime, timedelta

import pytz
import requests
from flask import Flask, request, jsonify
from waitress import serve

from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, CallbackQueryHandler, ContextTypes

from config import (
    BOT_TOKEN, WFP_MERCHANT, WFP_SECRET, MERCHANT_DOMAIN, PUBLIC_URL,
    SUBSCRIPTION_AMOUNT, CURRENCY, USERS_FILE
)

# === –õ–û–ì–ò ===
logging.basicConfig(level=logging.INFO)
log = logging.getLogger("vip-bot")

KYIV_TZ = pytz.timezone("Europe/Kyiv")

# === –ü–†–û–°–¢–ï –ó–ë–ï–†–ï–ñ–ï–ù–ù–Ø –ö–û–†–ò–°–¢–£–í–ê–ß–Ü–í ===
# –°—Ç—Ä—É–∫—Ç—É—Ä–∞: {
#   str(user_id): {
#       "payments": int,
#       "level": int,
#       "last_paid_at": "iso",
#       "recToken": str|None
#   }
# }
def load_users():
    try:
        with open(USERS_FILE, "r", encoding="utf-8") as f:
            return json.load(f)
    except Exception:
        return {}

def save_users(data):
    with open(USERS_FILE, "w", encoding="utf-8") as f:
        json.dump(data, f, ensure_ascii=False, indent=2)

USERS = load_users()

# === –ö–û–ù–°–¢–ê–ù–¢–ò –†–Ü–í–ù–Ü–í ===
# 1‚Üí20%, 2‚Üí25%, 3‚Üí30%, 4‚Üí35%, 5‚Üí40%, 6‚Üí45%
DISCOUNT_BY_PAYMENTS = {
    1: "20%",
    2: "25%",
    3: "30%",
    4: "35%",
    5: "40%",
    6: "45%",
}
# –ë–æ–Ω—É—Å–∏:
BONUSES = {
    2: "–ö–∞–≤–∞",
    3: "2 –∫–∞–≤–∏",
    4: "–ü—Ä–æ—Ç–µ—ó–Ω–æ–≤–∏–π –∫–æ–∫—Ç–µ–π–ª—å",
    5: "–ö–∞–≤–∞ + –ø—Ä–æ—Ç–µ—ó–Ω–æ–≤–∏–π –∫–æ–∫—Ç–µ–π–ª—å",
    6: "2 –∫–∞–≤–∏ + –ø—Ä–æ—Ç–µ—ó–Ω–æ–≤–∏–π –∫–æ–∫—Ç–µ–π–ª—å",
}
ALL_DISCOUNTS_LIST = [
    "1 —Ä—ñ–≤–µ–Ω—å ‚Üí 20%",
    "2 —Ä—ñ–≤–µ–Ω—å ‚Üí 25%",
    "3 —Ä—ñ–≤–µ–Ω—å ‚Üí 30%",
    "4 —Ä—ñ–≤–µ–Ω—å ‚Üí 35%",
    "5 —Ä—ñ–≤–µ–Ω—å ‚Üí 40%",
    "6 —Ä—ñ–≤–µ–Ω—å ‚Üí 45%",
]
ALL_BONUSES_LIST = [
    "2 —Ä—ñ–≤–µ–Ω—å ‚Üí –ö–∞–≤–∞",
    "3 —Ä—ñ–≤–µ–Ω—å ‚Üí 2 –∫–∞–≤–∏",
    "4 —Ä—ñ–≤–µ–Ω—å ‚Üí –ü—Ä–æ—Ç–µ—ó–Ω–æ–≤–∏–π –∫–æ–∫—Ç–µ–π–ª—å",
    "5 —Ä—ñ–≤–µ–Ω—å ‚Üí –ö–∞–≤–∞ + –ø—Ä–æ—Ç–µ—ó–Ω–æ–≤–∏–π –∫–æ–∫—Ç–µ–π–ª—å",
    "6 —Ä—ñ–≤–µ–Ω—å ‚Üí 2 –∫–∞–≤–∏ + –ø—Ä–æ—Ç–µ—ó–Ω–æ–≤–∏–π –∫–æ–∫—Ç–µ–π–ª—å",
]

def payments_to_level(payments: int) -> int:
    return min(max(payments, 0), 6)

def touch_user(user_id: int):
    sid = str(user_id)
    if sid not in USERS:
        USERS[sid] = {"payments": 0, "level": 0, "last_paid_at": None, "recToken": None}
        save_users(USERS)

# === WayForPay: –ø—ñ–¥–ø–∏—Å –¥–ª—è createInvoice ===
def wfp_signature(data_items):
    # –æ–±'—î–¥–Ω–∞–Ω–Ω—è —á–µ—Ä–µ–∑ ;
    base_str = ";".join(str(x) for x in data_items)
    digest = hmac.new(WFP_SECRET.encode("utf-8"), base_str.encode("utf-8"), hashlib.md5).hexdigest()
    return digest

def create_wfp_invoice(user_id: int) -> str:
    order_ref = f"vip_{user_id}_{int(time.time())}"
    order_date = int(time.time())
    amount = SUBSCRIPTION_AMOUNT

    # –ú—ñ–Ω—ñ–º–∞–ª—å–Ω—ñ –ø–æ–ª—è –¥–ª—è createInvoice
    payload = {
        "transactionType": "CREATE_INVOICE",
        "merchantAccount": WFP_MERCHANT,
        "merchantDomainName": MERCHANT_DOMAIN,
        "orderReference": order_ref,
        "orderDate": order_date,
        "amount": amount,
        "currency": CURRENCY,
        "productName": ["VIP –ø—ñ–¥–ø–∏—Å–∫–∞"],
        "productPrice": [amount],
        "productCount": [1],
        "serviceUrl": f"{PUBLIC_URL}/wfp-callback",  # –∫—É–¥–∏ WayForPay —à–ª–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç
        "returnUrl": f"https://t.me/{BOT_USERNAME}"
    }

    # –ü—ñ–¥–ø–∏—Å (–¥–∏–≤. –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü—ñ—é WayForPay: merchantSignature)
    # –ü–æ—Å–ª—ñ–¥–æ–≤–Ω—ñ—Å—Ç—å: merchantAccount;merchantDomainName;orderReference;orderDate;amount;currency;productName[0];productCount[0];productPrice[0]
    sig_items = [
        payload["merchantAccount"],
        payload["merchantDomainName"],
        payload["orderReference"],
        payload["orderDate"],
        payload["amount"],
        payload["currency"],
        payload["productName"][0],
        payload["productCount"][0],
        payload["productPrice"][0],
    ]
    payload["merchantSignature"] = wfp_signature(sig_items)

    r = requests.post("https://api.wayforpay.com/api", json=payload, timeout=15)
    r.raise_for_status()
    resp = r.json()
    # –û—á—ñ–∫—É—î–º–æ invoiceUrl
    invoice_url = resp.get("invoiceUrl")
    if not invoice_url:
        raise RuntimeError(f"WayForPay error: {resp}")
    return invoice_url

# === Telegram Bot ===
BOT_USERNAME = ""  # –ø—ñ–¥—Å—Ç–∞–≤–∏–º–æ –∑ /start (–¥–ª—è returnUrl)

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    global BOT_USERNAME
    if update.effective_chat.type == "private":
        BOT_USERNAME = context.bot.username

    user_id = update.effective_user.id
    touch_user(user_id)

    kb = [
        [InlineKeyboardButton("üí≥ –û–ø–ª–∞—Ç–∏—Ç–∏ 100 –≥—Ä–Ω (VIP)", callback_data="pay")],
        [InlineKeyboardButton("üéÅ –ú–æ—ó –±–æ–Ω—É—Å–∏", callback_data="bonuses"), InlineKeyboardButton("üìâ –ú–æ—ó –∑–Ω–∏–∂–∫–∏", callback_data="discounts")],
        [InlineKeyboardButton("üìä –ú—ñ–π —Ä—ñ–≤–µ–Ω—å", callback_data="level")],
        [InlineKeyboardButton("‚ÑπÔ∏è –£—Å—ñ –º–æ–∂–ª–∏–≤–æ—Å—Ç—ñ –∫–ª—É–±—É", callback_data="all")]
    ]
    if update.message:
        await update.message.reply_text("–í—ñ—Ç–∞—é —É VIP –∫–ª—É–±—ñ! –û–±–µ—Ä–∏ –æ–ø—Ü—ñ—é:", reply_markup=InlineKeyboardMarkup(kb))
    else:
        await update.callback_query.edit_message_text("–í—ñ—Ç–∞—é —É VIP –∫–ª—É–±—ñ! –û–±–µ—Ä–∏ –æ–ø—Ü—ñ—é:", reply_markup=InlineKeyboardMarkup(kb))

async def handle_buttons(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    user_id = query.from_user.id
    touch_user(user_id)
    sid = str(user_id)

    if query.data == "pay":
        # –°—Ç–≤–æ—Ä—é—î–º–æ —Ä–µ–∞–ª—å–Ω–∏–π —ñ–Ω–≤–æ–π—Å —É WayForPay
        try:
            invoice_url = create_wfp_invoice(user_id)
            kb = [[InlineKeyboardButton("–ü–µ—Ä–µ–π—Ç–∏ –¥–æ –æ–ø–ª–∞—Ç–∏", url=invoice_url)]]
            await query.edit_message_text("üîó –ù–∞—Ç–∏—Å–Ω–∏ –∫–Ω–æ–ø–∫—É, —â–æ–± –æ–ø–ª–∞—Ç–∏—Ç–∏ 100 –≥—Ä–Ω:", reply_markup=InlineKeyboardMarkup(kb))
        except Exception as e:
            log.exception("–ü–æ–º–∏–ª–∫–∞ —Å—Ç–≤–æ—Ä–µ–Ω–Ω—è —ñ–Ω–≤–æ–π—Å—É")
            await query.edit_message_text(f"‚ùå –ù–µ –≤–¥–∞–ª–æ—Å—å —Å—Ç–≤–æ—Ä–∏—Ç–∏ –æ–ø–ª–∞—Ç—É: {e}")

    elif query.data == "bonuses":
        level = USERS[sid]["level"]
        current = BONUSES.get(level, "–ù–∞—Ä–∞–∑—ñ –±–æ–Ω—É—Å—ñ–≤ –Ω–µ–º–∞—î. –ü—ñ–¥–Ω—ñ–º–∞–π —Ä—ñ–≤–µ–Ω—å üòâ")
        all_txt = "\n".join(ALL_BONUSES_LIST) + "\n\n*–ë–æ–Ω—É—Å–∏ –º–æ–∂–Ω–∞ –æ–±–º—ñ–Ω—è—Ç–∏ –Ω–∞ —ñ–Ω—à—ñ —Ç–æ–≤–∞—Ä–∏ —É —Å—Ö–æ–∂–æ–º—É —Ü—ñ–Ω–æ–≤–æ–º—É –¥—ñ–∞–ø–∞–∑–æ–Ω—ñ."
        await query.edit_message_text(f"üéÅ –¢–≤–æ—ó –±–æ–Ω—É—Å–∏: {current}\n\n–î–æ—Å—Ç—É–ø–Ω—ñ –±–æ–Ω—É—Å–∏ –∑–∞ —Ä—ñ–≤–Ω—è–º–∏:\n{all_txt}")

    elif query.data == "discounts":
        level = USERS[sid]["level"]
        current = DISCOUNT_BY_PAYMENTS.get(level, "–©–µ –Ω–µ–º–∞—î –∑–Ω–∏–∂–∫–∏")
        all_txt = "\n".join(ALL_DISCOUNTS_LIST)
        await query.edit_message_text(f"üìâ –¢–≤–æ—è –∑–Ω–∏–∂–∫–∞: {current}\n\n–î–æ—Å—Ç—É–ø–Ω—ñ –∑–Ω–∏–∂–∫–∏ –∑–∞ —Ä—ñ–≤–Ω—è–º–∏:\n{all_txt}")

    elif query.data == "level":
        level = USERS[sid]["level"]
        p = USERS[sid]["payments"]
        last = USERS[sid]["last_paid_at"]
        last_txt = last if last else "‚Äî"
        await query.edit_message_text(f"üìä –¢–≤—ñ–π —Ä—ñ–≤–µ–Ω—å: {level} \n–û–ø–ª–∞—á–µ–Ω–∏—Ö –º—ñ—Å—è—Ü—ñ–≤: {p}\n–û—Å—Ç–∞–Ω–Ω—è –æ–ø–ª–∞—Ç–∞: {last_txt}")

    elif query.data == "all":
        bonuses = "\n".join(ALL_BONUSES_LIST)
        discounts = "\n".join(ALL_DISCOUNTS_LIST)
        await query.edit_message_text(f"üéÅ –ë–æ–Ω—É—Å–∏:\n{bonuses}\n\nüìâ –ó–Ω–∏–∂–∫–∏:\n{discounts}\n\n*–ë–æ–Ω—É—Å–∏ –º–æ–∂–Ω–∞ –æ–±–º—ñ–Ω—è—Ç–∏ –Ω–∞ —ñ–Ω—à—ñ —Ç–æ–≤–∞—Ä–∏ —É —Å—Ö–æ–∂–æ–º—É —Ü—ñ–Ω–æ–≤–æ–º—É –¥—ñ–∞–ø–∞–∑–æ–Ω—ñ.")

def inc_level_after_success(user_id: int):
    sid = str(user_id)
    touch_user(user_id)
    USERS[sid]["payments"] += 1
    USERS[sid]["level"] = payments_to_level(USERS[sid]["payments"])
    USERS[sid]["last_paid_at"] = datetime.now(KYIV_TZ).isoformat(timespec="seconds")
    save_users(USERS)

# === Flask –¥–ª—è –ø—Ä–∏–π–æ–º—É callback –≤—ñ–¥ WayForPay ===
app = Flask(__name__)

@app.post("/wfp-callback")
def wfp_callback():
    try:
        data = request.get_json(force=True, silent=True) or {}
        log.info("WFP callback: %s", data)

        reason_code = str(data.get("reasonCode", ""))
        txn_status = data.get("transactionStatus", "")
        order_ref = data.get("orderReference", "")
        # –°–ø—Ä–æ–±—É—î–º–æ –≤–∏—Ç—è–≥—Ç–∏ user_id –∑ orderReference vip_{user_id}_{ts}
        uid = None
        if order_ref.startswith("vip_"):
            try:
                uid = int(order_ref.split("_")[1])
            except Exception:
                uid = None

        # –Ø–∫—â–æ —É—Å–ø—ñ—à–Ω–æ ‚Äî –æ–Ω–æ–≤–ª—é—î–º–æ —Ä—ñ–≤–µ–Ω—å
        if txn_status in ("Approved", "InProcessing") and reason_code in ("1100", "0", ""):
            if uid:
                inc_level_after_success(uid)

        # –Ø–∫—â–æ –ø—Ä–∏–π–¥–µ recToken (–¥–ª—è —Ä–µ–∫—É—Ä–µ–Ω—Ç—ñ–≤) ‚Äî –∑–±–µ—Ä–µ–∂–µ–º–æ
        if uid and "recToken" in data:
            sid = str(uid)
            touch_user(uid)
            USERS[sid]["recToken"] = data.get("recToken")
            save_users(USERS)

        return jsonify({"code": "accept"})
    except Exception as e:
        log.exception("callback error")
        return jsonify({"code": "error", "message": str(e)}), 500

# === –§–æ–Ω–æ–≤–∏–π –∑–∞–¥–∞—á–Ω–∏–∫: —â–æ–¥–µ–Ω–Ω–∞ –ø–µ—Ä–µ–≤—ñ—Ä–∫–∞ –ø—Ä–æ—Å—Ç—Ä–æ—á–∫–∏ (30+3 –¥–Ω—ñ) ===
async def daily_overdue_check(app_telegram: Application):
    from datetime import datetime, timedelta
    while True:
        try:
            now = datetime.now(KYIV_TZ)
            for sid, u in list(USERS.items()):
                last = u.get("last_paid_at")
                if not last:
                    continue
                try:
                    last_dt = datetime.fromisoformat(last)
                except Exception:
                    continue
                # 33 –¥–Ω—ñ –≤—ñ–¥ –æ—Å—Ç–∞–Ω–Ω—å–æ—ó –æ–ø–ª–∞—Ç–∏ ‚Äî —Å–∫–∏–¥–∞–Ω–Ω—è
                if now - last_dt > timedelta(days=33):
                    u["level"] = 0
                    u["payments"] = 0
            save_users(USERS)
        except Exception:
            pass
        await asyncio.sleep(24 * 60 * 60)

async def on_start(app_telegram: Application):
    asyncio.create_task(daily_overdue_check(app_telegram))

def run_flask():
    from waitress import serve
    import os
    serve(app, host="0.0.0.0", port=int(os.environ.get("PORT", "8080")))

async def main_async():
    application = Application.builder().token(BOT_TOKEN).post_init(on_start).build()
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CallbackQueryHandler(handle_buttons))

    # Flask —É –æ–∫—Ä–µ–º–æ–º—É –ø–æ—Ç–æ—Ü—ñ
    import threading
    t = threading.Thread(target=run_flask, daemon=True)
    t.start()

    log.info("Bot is starting...")
    await application.run_polling()

if __name__ == "__main__":
    import os
    asyncio.run(main_async())
